<?php
/**
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.
 * Licensed under the MIT License.  See License in the project root
 * for license information.
 */


namespace Microsoft\Graph\Core\Requests;

use League\Uri\Contracts\UriException;
use Microsoft\Kiota\Abstractions\RequestInformation;
use Microsoft\Kiota\Abstractions\Serialization\Parsable;
use Microsoft\Kiota\Abstractions\Serialization\SerializationWriter;
use Psr\Http\Message\RequestInterface;
use Ramsey\Uuid\Uuid;

/**
 * Class BatchRequestItem
 *
 * Individual request within a Batch Request
 *
 * @package Microsoft\Graph\Core
 * @copyright 2022 Microsoft Corporation
 * @license https://opensource.org/licenses/MIT MIT License
 * @link https://developer.microsoft.com/graph
 */
class BatchRequestItem implements Parsable
{
    /**
     * Unique identifier
     *
     * @var string
     */
    private string $id;

    /**
     * HTTP Method
     *
     * @var string
     */
    private string $method;

    /**
     * Relative request URL e.g. /users
     *
     * @var string
     */
    private string $url;

    /**
     * Request headers. Should contain content-type based on type of $body
     * e.g. JSON - application/json, Text - text/plain
     *
     * @var array<string, string>
     */
    private array $headers = [];

    /**
     * JSON string. Defaults to null
     *
     * @var string|null
     */
    private ?string $body = null;

    /**
     * Must NOT be identical to any request's $id.
     * Requests with same atomicityGroup are processed atomically - all fail or all succeed
     *
     * @var string
     */
    private string $atomicityGroup;

    /**
     * List of request $id's. Request executes only if dependent requests were successful.
     * If depends on a request with a different $atomicityGroup, then $atomicityGroup should be included here.
     *
     * @var array<string>
     */
    private array $dependsOn = [];

    /**
     * Condition for executing. Value is a URL expression e.g
     * '$[another-request-id]/$succeeded' => executes if referenced request succeeds
     * '$[request-id]' to reference response body of referenced request
     * '$[request-id]/[path]' to reference part of the referenced request's response body
     * For more info see https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_BatchRequest
     *
     * @var string
     */
    private string $if;

    /**
     * @param RequestInformation $requestInformation. Fluent Request Builder paths have create[Get|Put|Post|Delete|Patch]RequestInformation functions
     * @param string $id. Auto-generated by default.
     * @param array<string|BatchRequestItem> $dependsOn List of request IDs or BatchRequestItems this request depends on
     * @param string $atomicityGroup
     * @throws UriException
     * @throws \JsonException
     */
    public function __construct(RequestInformation $requestInformation, string $id = "", array $dependsOn = [], string $atomicityGroup = "")
    {
        if (!$requestInformation->httpMethod) {
            throw new \InvalidArgumentException("HTTP method cannot be NULL/empty");
        }
        $this->id = ($id) ?? Uuid::uuid4();
        $this->method = $requestInformation->httpMethod;
        $this->setUrl($requestInformation->getUri());
        $this->headers = $requestInformation->headers;
        $this->body = ($requestInformation->content) ? urlencode(json_encode($requestInformation->content->getContents(), JSON_THROW_ON_ERROR)) : null;
        $this->dependsOn($dependsOn);
        $this->atomicityGroup = $atomicityGroup;
    }

    /**
     * @param RequestInterface $psrRequest. MUST contain URL and HTTP method
     * @param string $id Auto-generated by default.
     * @param array<string|BatchRequestItem> $dependsOn List of request IDs or BatchRequestItems this request depends on
     * @param string $atomicityGroup @see $atomicityGroup
     * @return BatchRequestItem
     * @throws \JsonException
     * @throws UriException
     */
    public static function createWithPsrRequest(RequestInterface $psrRequest, string $id = "", array $dependsOn = [], string $atomicityGroup = ""): BatchRequestItem
    {
        $requestInfo = new RequestInformation();
        $requestInfo->httpMethod = $psrRequest->getMethod();
        $requestInfo->setUri($psrRequest->getUri());
        foreach ($psrRequest->getHeaders() as $key => $value) {
            $requestInfo->headers [] = [strtolower($key) => strtolower(implode(",", $value))];
        }
        $requestInfo->content = $psrRequest->getBody();
        return new BatchRequestItem($requestInfo, $id, $dependsOn, $atomicityGroup);
    }

    /**
     * Create dependency between Batch Request Items
     *
     * @param array<string|BatchRequestItem> $requests List of request IDs or BatchRequestItems this request depends on
     * @return void
     */
    public function dependsOn(array $requests)
    {
        foreach ($requests as $request) {
            if (is_a($request, BatchRequestItem::class)) {
                // Add atomicity group if dependency request belongs to different atomicity group
                $this->dependsOn [] = ($this->atomicityGroup === $request->getAtomicityGroup()) ?
                                        $request->getAtomicityGroup() : $request->getId();
                continue;
            }
            $this->dependsOn[] = strval($request);
        }
    }

    /**
     * @param string $url
     */
    public function setUrl(string $url): void
    {
        // Set relative URL
        $urlParts = parse_url($url);
        if (!$urlParts) {
            throw new \InvalidArgumentException("Invalid URL {$url}");
        }
        // Set relative URL
        $this->url = "{$urlParts['path']}{$urlParts['query']}{$urlParts['fragment']}";
    }

    /**
     * @return string
     */
    public function getId(): string
    {
        return $this->id;
    }

    /**
     * @param string $id
     */
    public function setId(string $id): void
    {
        $this->id = $id;
    }

    /**
     * @return string
     */
    public function getMethod(): string
    {
        return $this->method;
    }

    /**
     * @param string $method
     */
    public function setMethod(string $method): void
    {
        $this->method = $method;
    }

    /**
     * @return string
     */
    public function getUrl()
    {
        return $this->url;
    }

    /**
     * @return string[]
     */
    public function getHeaders(): array
    {
        return $this->headers;
    }

    /**
     * @param string[] $headers
     */
    public function setHeaders(array $headers): void
    {
        $this->headers = $headers;
    }

    /**
     * @return string
     */
    public function getBody(): ?string
    {
        return $this->body;
    }

    /**
     * @param string|null $body
     */
    public function setBody(?string $body): void
    {
        $this->body = $body;
    }

    /**
     * @return string
     */
    public function getAtomicityGroup(): string
    {
        return $this->atomicityGroup;
    }

    /**
     * @param string $atomicityGroup
     */
    public function setAtomicityGroup(string $atomicityGroup): void
    {
        $this->atomicityGroup = $atomicityGroup;
    }

    /**
     * @return string[]. List of request IDs
     */
    public function getDependsOn(): array
    {
        return $this->dependsOn;
    }

    /**
     * @return string
     */
    public function getIf(): string
    {
        return $this->if;
    }

    /**
     * @param string $if
     */
    public function setIf(string $if): void
    {
        $this->if = $if;
    }

    public function getFieldDeserializers(): array
    {
        return [];
    }

    public function serialize(SerializationWriter $writer): void
    {
        $writer->writeStringValue('id', $this->getId());
        $writer->writeStringValue('method', $this->getMethod());
        $writer->writeStringValue('url', $this->getUrl());
        $writer->writeStringValue('atomicityGroup', $this->getAtomicityGroup());
        $writer->writeCollectionOfPrimitiveValues('dependsOn', $this->getDependsOn());
        $writer->writeStringValue('if', $this->getIf());
        $writer->writeCollectionOfPrimitiveValues('headers', $this->getHeaders());
        $writer->writeStringValue('body', $this->getBody());
    }
}
